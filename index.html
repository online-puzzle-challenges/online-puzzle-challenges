<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Puzzle House</title>

  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 700px;
      margin: 40px auto;
      line-height: 1.6;
    }

    button {
      padding: 8px 14px;
      margin-top: 10px;
      cursor: pointer;
    }

    input {
      padding: 8px;
      width: 100%;
      margin-top: 8px;
    }

    .locked {
      opacity: 0.5;
    }

    .room {
      border-top: 1px solid #ddd;
      padding-top: 12px;
      margin-top: 12px;
    }
  </style>
</head>
<body>

  <h1>Puzzle House</h1>

<div>
  <label for="hallSelect">Select Puzzle Hall:</label>
  <select id="hallSelect"></select>
</div>
<div id="app"></div>


  <script>
    /*********************************************************
     * PHASE 1 DATA MODEL
     *********************************************************/

    const PUZZLE_HOUSE = {
      halls: {
        nate: {
          displayName: "Nateâ€™s Puzzle Hall",
          rooms: [
            {
              id: "nate-1",
              title: "The First Door",
              description: "Sometimes the key is exactly what it sounds like.",
              key: "the key", // Phase 1: plaintext (weâ€™ll hash later)
              hints: [
                "Read the instructions literally."
              ]
            },
            {
              id: "nate-2",
              title: "Second Thoughts",
              description: "You may not be ready for this room yet.",
              key: "patience",
              hints: [
                "Waiting is part of the solution."
              ]
            },
			{
			  id: "nate-3",
			  title: "Room Title Goes Here",
			  description: "What the player sees when they enter the room.",
			  key: "the answer",
			  hints: [
				"First gentle nudge.",
				"Clearer direction.",
				"Near-spoiler if needed."
			  ]
}
          ]
        }
      }
    };
	
let currentHallId = Object.keys(PUZZLE_HOUSE.halls)[0]; // default to first hall

function populateHallDropdown() {
  const select = document.getElementById("hallSelect");
  select.innerHTML = ""; // clear existing options

  Object.entries(PUZZLE_HOUSE.halls).forEach(([hallId, hall]) => {
    const option = document.createElement("option");
    option.value = hallId;
    option.textContent = hall.displayName;
    if (hallId === currentHallId) option.selected = true;
    select.appendChild(option);
  });

  select.onchange = () => {
    currentHallId = select.value;
    render();
  };
}


    /*********************************************************
     * PROGRESS PERSISTENCE
     *********************************************************/

    const STORAGE_KEY = "puzzleHouseProgress";

    function loadProgress() {
      return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {
        unlockedRooms: {}
      };
    }

    function saveProgress(progress) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
    }

    let progress = loadProgress();

    /*********************************************************
     * CORE LOGIC
     *********************************************************/

    function normalizeInput(str) {
      return str.trim().toLowerCase();
    }

    function attemptUnlock(room, userInput) {
      const normalized = normalizeInput(userInput);
      if (normalized === room.key) {
        progress.unlockedRooms[room.id] = true;
        saveProgress(progress);
        return true;
      }
      return false;
    }

    function isUnlocked(room) {
      return progress.unlockedRooms[room.id];
    }

    /*********************************************************
     * RENDERING
     *********************************************************/

	function render() {
	const app = document.getElementById("app");
	app.innerHTML = "";

	const hall = PUZZLE_HOUSE.halls[currentHallId];

	const hallHeader = document.createElement("h2");
	hallHeader.textContent = hall.displayName;
	app.appendChild(hallHeader);

	  const resetHallBtn = document.createElement("button");
	  resetHallBtn.textContent = "Reset Hall Progress";
	  resetHallBtn.className = "danger";
	  resetHallBtn.onclick = () => {
		if (confirm("Re-lock all rooms in this hall?")) {
		  relockFromRoom(hall, 0);
		  render();
		}
	  };
	  app.appendChild(resetHallBtn);

	  hall.rooms.forEach((room, index) => {
    const roomDiv = document.createElement("div");
    roomDiv.className = "room";

    const accessible = index === 0 || isUnlocked(hall.rooms[index - 1]);

    if (!accessible) {
      roomDiv.classList.add("locked");
      roomDiv.textContent = "ðŸ”’ Locked";
      app.appendChild(roomDiv);
      return;
    }

    const title = document.createElement("h3");
    title.textContent = room.title;

    const desc = document.createElement("p");
    desc.textContent = room.description;

    roomDiv.appendChild(title);
    roomDiv.appendChild(desc);

    if (isUnlocked(room)) {
      const status = document.createElement("p");
      status.textContent = "âœ… Unlocked";

      const relockBtn = document.createElement("button");
      relockBtn.textContent = "Re-lock from here";
      relockBtn.className = "danger";
      relockBtn.onclick = () => {
        if (confirm("This will re-lock this room and all rooms after it. Continue?")) {
          relockFromRoom(hall, index);
          render();
        }
      };

      roomDiv.appendChild(status);
      roomDiv.appendChild(relockBtn);
    } else {
      const input = document.createElement("input");
      input.placeholder = "Enter keyâ€¦";

      const btn = document.createElement("button");
      btn.textContent = "Unlock";
      btn.onclick = () => {
        alert(attemptUnlock(room, input.value)
          ? "Unlocked!"
          : "Incorrect key.");
        render();
      };

      roomDiv.appendChild(input);
      roomDiv.appendChild(btn);
    }

    app.appendChild(roomDiv);
  });
}
	populateHallDropdown();
    render();
  </script>

</body>
</html>
